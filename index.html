<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Mobile-friendly viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini Battle Chess 9000 - Ultra Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        .ui-layer { position: absolute; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
        #hud { top: 20px; text-shadow: 0 0 10px rgba(0,255,0,0.8); }
        h1 { margin: 0; color: #fff; text-transform: uppercase; letter-spacing: 4px; font-size: 24px; }
        #status { color: #aaa; margin-top: 5px; font-size: 16px; font-weight: bold; }
        #player-display { color: #4da6ff; font-size: 14px; margin-top: 5px; font-family: monospace; letter-spacing: 1px; text-shadow: 0 0 5px #4da6ff;}

        /* ALERTS & TRACKERS */
        #check-alert { 
            display: none; 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 100px; font-weight: 900; color: red; 
            text-shadow: 0 0 20px black; border: 5px solid red; padding: 20px 50px; 
            background: rgba(0,0,0,0.7); z-index: 500;
            animation: pulse-alert 0.5s infinite alternate;
            pointer-events: none;
        }
        @keyframes pulse-alert { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.1); } }

        .tracker { 
            position: absolute; top: 100px; width: 50px; bottom: 100px;
            display: flex; flex-direction: column; gap: 5px; padding: 10px; 
            pointer-events: none; z-index: 5;
        }
        .tracker-left { left: 10px; align-items: flex-start; }
        .tracker-right { right: 10px; align-items: flex-end; }
        
        .capture-icon { 
            width: 45px; height: 45px; object-fit: contain; 
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.8));
            transition: transform 0.2s;
        }
        .capture-icon:hover { transform: scale(1.5); }

        /* MODALS */
        .modal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); z-index: 2000; 
            display: none; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; overflow-y: auto;
        }
        .modal.active { display: flex; }

        .menu-box { 
            background: rgba(20, 20, 20, 0.95); padding: 40px; border: 1px solid #444; 
            box-shadow: 0 0 50px rgba(0,0,0,1), 0 0 20px rgba(77, 166, 255, 0.2); 
            text-align: center; border-radius: 8px;
            max-width: 500px; width: 90%;
            position: relative;
        }

        /* SHOWCASE UI LAYOUT (NEW) */
        #showcase-ui {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 50;
        }
        #showcase-ui.active { display: block; }
        
        .sc-panel {
            position: absolute; background: rgba(10,10,10,0.85); border: 1px solid #333;
            pointer-events: auto; display: flex; flex-direction: column; gap: 10px; padding: 10px;
            border-radius: 8px; backdrop-filter: blur(4px);
        }
        
        #sc-top { 
            top: 10px; left: 50%; transform: translateX(-50%); width: 500px; 
            flex-direction: column; align-items: center; justify-content: center;
        }
        #sc-top-row { display: flex; width: 100%; gap: 10px; align-items: center; }
        #sc-credit { font-size: 11px; color: #888; margin-top: 5px; font-family: monospace; display: flex; align-items: center; gap: 5px; }
        #sc-credit img { width: 16px; height: 16px; border-radius: 50%; }
        #sc-credit a { color: #4da6ff; text-decoration: none; }

        #sc-left { top: 100px; bottom: 80px; left: 10px; width: 70px; overflow-y: auto; align-items: center; }
        #sc-right { top: 100px; bottom: 80px; right: 10px; width: 70px; overflow-y: auto; align-items: center; }
        #sc-bottom { bottom: 10px; left: 50%; transform: translateX(-50%); width: 500px; flex-direction: row; justify-content: center; align-items: center;}

        .sc-btn { 
            width: 50px; height: 50px; border: 1px solid #444; background: #222; 
            cursor: pointer; display: flex; justify-content: center; align-items: center;
            transition: 0.2s; border-radius: 4px;
        }
        .sc-btn:hover { background: #444; border-color: #fff; transform: scale(1.1); }
        .sc-btn.selected { border-color: #28a745; background: #1a3a1a; box-shadow: 0 0 10px #28a745; }
        .sc-btn img { width: 100%; height: 100%; object-fit: contain; }

        .sc-tab { padding: 10px 20px; background: #333; color: #888; border: 1px solid #444; cursor: pointer; flex: 1; text-align: center; font-size: 12px;}
        .sc-tab.active { background: #4da6ff; color: #000; font-weight: bold; border-color: #fff; }
        
        /* STANDARD UI ELEMENTS */
        .avatar-grid { 
            display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin: 15px 0;
            background: #000; padding: 10px; border-radius: 4px; border: 1px solid #333;
        }
        .avatar-option { 
            background: #1a1a1a; border: 2px solid #333; border-radius: 4px; padding: 2px; 
            cursor: pointer; transition: 0.2s; display: flex; align-items: center; justify-content: center;
            aspect-ratio: 1 / 1;
        }
        .avatar-option:hover { border-color: #666; background: #333; }
        .avatar-option.selected { border-color: #28a745; background: #1a3a1a; box-shadow: 0 0 10px #28a745; }
        .avatar-option img { width: 100%; height: 100%; object-fit: contain; }

        .player-list { list-style: none; padding: 0; margin: 20px 0; max-height: 250px; overflow-y: auto; border: 1px solid #333; background: #000; }
        .player-item { display: flex; align-items: center; justify-content: space-between; padding: 10px; background: #111; border-bottom: 1px solid #222; }
        .player-item:hover { background: #222; }
        .player-info { display: flex; align-items: center; gap: 10px; text-align: left; }
        .player-stats { font-size: 11px; color: #888; display: block; }
        
        .challenge-btn { 
            width: auto; padding: 5px 15px; background: #4da6ff; border: none; 
            color: #000; font-weight: bold; font-size: 12px; cursor: pointer;
            box-shadow: 0 0 10px rgba(77, 166, 255, 0.4);
        }
        .challenge-btn:hover { background: #fff; box-shadow: 0 0 20px rgba(77, 166, 255, 0.8); }

        /* CHALLENGE POPUP */
        .challenge-alert {
            background: #4da6ff; color: #000; padding: 20px; border-radius: 8px;
            animation: pulse-alert 1s infinite;
        }      

        select, button, input[type="text"], .toggle-group { 
            display: block; width: 100%; padding: 12px; margin: 10px 0; box-sizing: border-box;
            font-size: 16px; background: #222; color: white; border: 1px solid #444; 
            cursor: pointer; transition: 0.3s;
        }
        input[type="text"] { cursor: text; text-align: center; font-weight: bold; border: 1px solid #444; }
        input[type="text"]:focus { outline: none; border-color: #28a745; box-shadow: 0 0 15px rgba(40, 167, 69, 0.3); }

        button { background: #333; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        button:hover { background: #444; border-color: #666; }
        
        .main-actions { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        .action-row { display: flex; gap: 10px; }
        .action-btn { flex: 1; border: none; }
        
        .promo-options { display: flex; gap: 20px; margin-top:20px; justify-content: center;}
        .promo-piece { 
            width: 60px; height: 60px; background: #333; border: 2px solid #555;
            display: flex; align-items: center; justify-content: center;
            font-size: 30px; cursor: pointer; color: #fff;
        }
        .promo-piece:hover { background: #555; border-color: white; }

        #battle-overlay { 
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: black; z-index: 3000; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto;
        }
        video { width: 100%; height: 80%; object-fit: contain; }
        #video-msg { color: #ff5555; font-family: monospace; font-size: 18px; margin-bottom: 20px; }
        #skip-btn { width: auto; display: inline-block; background: transparent; border: 2px solid white; margin-top: 20px; }
        #skip-btn:hover { background: white; color: black; }

        .link-box {
            background: #000; border: 1px solid #4da6ff; color: #4da6ff;
            padding: 10px; width: 100%; text-align: center; font-family: monospace;
            margin-bottom: 15px; cursor: pointer;
        }

        .endgame-content { max-height: 80vh; overflow-y: auto; text-align: left; padding-right: 10px; }
        .endgame-content::-webkit-scrollbar { width: 8px; }
        .endgame-content::-webkit-scrollbar-track { background: #111; }
        .endgame-content::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        .prompt-block {
            background: #000; border: 1px solid #333; padding: 15px; margin-bottom: 20px;
            font-family: monospace; font-size: 12px; color: #0f0; white-space: pre-wrap;
            text-align: left;
        }
        h3 { border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 30px; color: #ddd; }
        p { line-height: 1.6; color: #bbb; }
        .highlight { color: #fff; font-weight: bold; }
        a { color: #4da6ff; text-decoration: none; }
        a:hover { text-decoration: underline; }

        /* LIGHTING UI */
        .lighting-toggle {
            position: absolute; top: 20px; right: 20px; width: 32px; height: 32px; border-radius: 50%;
            background: rgba(0,0,0,0.8); border: 1px solid #555; color: #ffd700;
            display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 30; pointer-events: auto;
        }
        .lighting-toggle:hover { background: rgba(40,40,40,0.95); }
        .lighting-panel {
            position: absolute; top: 62px; right: 20px; width: 220px; background: rgba(10,10,10,0.96);
            border: 1px solid #444; border-radius: 8px; padding: 10px 12px 12px; z-index: 30; color: #ddd; font-size: 12px; box-shadow: 0 0 20px rgba(0,0,0,0.95); pointer-events: auto;
        }
        .lighting-panel.hidden { display: none; }
        .lighting-panel h3 { margin: 0 0 6px; font-size: 12px; text-align: left; color: #4da6ff; }
        .lighting-panel label { display: flex; justify-content: space-between; align-items: center; font-size: 11px; margin-top: 6px; }
        .lighting-panel span.value { color: #888; font-family: monospace; }
        .lighting-panel input[type="range"] { width: 100%; }

        @media (max-width: 768px) {
            .menu-box { width: 95%; padding: 15px; max-height: 95vh; overflow-y: auto; }
            .avatar-grid { grid-template-columns: repeat(4, 1fr); }
            .tracker { flex-direction: row; width: 100%; height: 40px; top: auto; bottom: 10px; padding: 0; justify-content: center; gap: 5px; }
            .tracker-left { left: 0; bottom: 50px; align-items: center; }
            .tracker-right { right: 0; bottom: 10px; align-items: center; }
            .capture-icon { width: 35px; height: 35px; }
            #check-alert { font-size: 40px; width: 80%; }
            #sc-left, #sc-right { width: 50px; top: 140px; }
            #sc-top { width: 90%; }
            #sc-bottom { width: 90%; }
            .sc-btn { width: 40px; height: 40px; }
        }
    </style>

    <!-- CORE THREE.JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <!-- POST PROCESSING SHADERS (BLOOM) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>

    <!-- START MENU -->
    <div id="start-menu" class="modal active">
        <div class="menu-box">
            <!-- INSPIRATION IMAGE -->
            <img src="battle_chess_1988.png" alt="1988 Inspiration"
                 style="max-width: 100%; max-height: 180px; margin-bottom: 15px;
                        border-radius: 4px; border: 1px solid #444;
                        box-shadow: 0 0 15px rgba(0,0,0,0.8);">

            <h2 style="margin-top:0; margin-bottom: 5px; color: #4da6ff; text-shadow: 0 0 10px #4da6ff;">
                BATTLE CHESS 9000
            </h2>
            <p style="color: #666; font-size: 13px; font-style: italic; margin-top: 0; margin-bottom: 20px;">
                Inspired by Battle Chess for DOS 1988
            </p>
            
            <input type="text" id="player-name-input" placeholder="ENTER YOUR NAME" maxlength="15">
            
            <label style="margin-top: 15px; color: #aaa; font-size: 14px;">Select Game Theme</label>
            <select id="theme-select" onchange="updateAvatarGrid()"><option disabled selected>Loading...</option></select>
            
            <label style="margin-top: 15px; color: #aaa; font-size: 14px;">Choose Avatar</label>
            <div id="avatar-grid" class="avatar-grid"></div>
            
            <div class="main-actions">
                <div class="action-row">
                    <button onclick="joinLobby()" style="background:#4da6ff; color:black; flex:2; box-shadow: 0 0 15px rgba(77, 166, 255, 0.4);">ENTER LOBBY</button>
                    <button onclick="createPrivateGame()" style="background:#8a2be2; color:white; flex:1; box-shadow: 0 0 15px rgba(138, 43, 226, 0.4);">INVITE</button>
                </div>
                <div class="action-row">
                    <button class="action-btn" onclick="startGameAI()">VS AI (SOLO)</button>
                    <button class="action-btn" onclick="startGameLocal()">VS FRIEND (LOCAL)</button>
                </div>
                <!-- NEW SHOWCASE BUTTON -->
                <button onclick="openShowcase()" style="background:#333; color:#aaa; margin-top:10px; border:1px solid #555;">THEME SHOWCASE</button>
            </div>
        </div>
    </div>

    <!-- SHOWCASE UI (NEW) -->
    <div id="showcase-ui">
        <div id="sc-top" class="sc-panel">
            <div id="sc-top-row">
                <select id="sc-theme-select" onchange="updateShowcaseTheme()" style="margin:0; padding:5px; width:auto; flex:2;"></select>
                <button onclick="showcaseBoard()" style="flex:1; margin:0; padding:5px; font-size:12px;">VIEW BOARD</button>
                <button onclick="closeShowcase()" style="flex:0.5; margin:0; padding:5px; background:#444; color:white;">X</button>
            </div>
            <div id="sc-credit">Loading credit...</div>
        </div>
        <div id="sc-left" class="sc-panel">
            <!-- White Pieces Injected Here -->
        </div>
        <div id="sc-right" class="sc-panel">
            <!-- Black Pieces Injected Here -->
        </div>
        <div id="sc-bottom" class="sc-panel">
            <div id="sc-mode-explore" class="sc-tab active" onclick="setShowcaseMode('explore')">EXPLORE ASSETS</div>
            <div id="sc-mode-battle" class="sc-tab" onclick="setShowcaseMode('battle')">BATTLE PREVIEW</div>
            <button id="sc-fight-btn" onclick="triggerShowcaseBattle()" style="display:none; background:#d00; color:white; margin-left:10px;">WATCH FIGHT</button>
        </div>
    </div>

    <!-- LOBBY MENU -->
    <div id="lobby-menu" class="modal">
        <div class="menu-box">
            <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #333; padding-bottom:10px; margin-bottom:10px;">
                <h2 style="margin:0; color:#4da6ff;">LOBBY</h2>
                <button onclick="disconnectSocket()" style="width:auto; padding:5px 10px; font-size:12px; background:#444;">Exit</button>
            </div>
            
            <div style="display:flex; align-items:center; justify-content:center; gap:10px; margin-bottom:15px; background: #222; padding: 10px; border-radius: 4px;">
                <img id="my-avatar-display" src="" style="width:40px; height:40px; object-fit: contain;">
                <h3 id="my-name-display" style="margin:0; color:#28a745;"></h3>
            </div>

            <p style="text-align: left; color: #888; font-size: 12px; margin-bottom: 5px;">ONLINE COMMANDERS:</p>
            <ul id="lobby-list" class="player-list">
                <li style="padding:10px; color:#666;">Connecting to server...</li>
            </ul>
        </div>
    </div>

    <!-- INVITE LINK WAITING ROOM -->
    <div id="invite-menu" class="modal">
        <div class="menu-box">
            <h2 style="color: #8a2be2; text-shadow: 0 0 10px #8a2be2;">PRIVATE GAME</h2>
            <p>Share this link to battle:</p>
            <input type="text" id="invite-link-box" class="link-box" readonly onclick="this.select(); document.execCommand('copy'); alert('Link Copied!')">
            <p style="font-size: 12px; color: #666;">Waiting for opponent to join...</p>
            <div class="action-row">
                <button onclick="disconnectSocket()" style="background:#444;">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- CHALLENGE POPUP -->
    <div id="challenge-modal" class="modal">
        <div class="menu-box challenge-alert">
            <h2>⚔️ CHALLENGE! ⚔️</h2>
            <p id="challenger-name">Player X wants to battle!</p>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                <button onclick="acceptChallenge()" style="background:white; color:black; flex:1;">ACCEPT</button>
                <button onclick="declineChallenge()" style="background:#222; color:white; flex:1;">DECLINE</button>
            </div>
        </div>
    </div>

    <!-- PROMOTION MENU -->
    <div id="promo-modal" class="modal">
        <div class="menu-box">
            <h2>Promote Pawn</h2>
            <div class="promo-options">
                <div class="promo-piece" onclick="commitPromotion('q')">♕</div>
                <div class="promo-piece" onclick="commitPromotion('r')">♖</div>
                <div class="promo-piece" onclick="commitPromotion('b')">♗</div>
                <div class="promo-piece" onclick="commitPromotion('n')">♘</div>
            </div>
        </div>
    </div>

    <!-- GAME OVER / INFO MODAL -->
    <div id="game-over-modal" class="modal">
        <div class="menu-box" style="width: 800px; max-width: 95%;">
            <div class="endgame-content">
                <h1 id="end-title" style="text-align: center; color: #28a745;">GAME OVER</h1>
                <p id="end-reason" style="text-align: center; font-size: 18px; margin-bottom: 30px;"></p>

                <div style="background: #222; padding: 20px; border-left: 4px solid #4da6ff; margin-bottom: 20px;">
                    <p style="margin-top:0; font-style: italic;">
                        "This game was fully vibe coded over an afternoon with <strong>Gemini-3, Nano Banana 3, and Veo3</strong> plus an API key."
                    </p>
                    <p>
                        Did you enjoy your Battle Chess experience? Did the animations live up to your expectations?
                    </p>
                    <p style="font-weight: bold; color: white;">
                        Please write up your experience in a Tweet, LinkedIn post, or Blog! Share with your kids, friends, and colleagues.
                    </p>
                </div>

                <h3>How It Was Made (The Prompts)</h3>
                <p>Want to fork this? Run the asset-generator in the repo and use these exact prompts to recreate this theme:</p>
                
                <p class="highlight">1. Theme Title:</p>
                <div class="prompt-block">medieval_classic</div>

                <p class="highlight">2. Board Style:</p>
                <div class="prompt-block">Medeival 1600s castles with white marble and black obsidian as classical a chessboard you can make with these matierals at the time. Do NOT display pieces just the board and its polished matierals of marble and black obsidian.</div>

                <p class="highlight">3. Piece Style:</p>
                <div class="prompt-block">"These are chess pieces in a set. Do not deviate from classic chess pieces but be creative. The Pawns should be peasants or orcs not just chess pawns. As with the rest of the pieces. 1600s medieval European style with White as holy good and Black as gothic evil, showing a noble crowned king, regal robed queen, Catholic bishops with mitres, armored knights on warhorses, fortified stone castle rooks, and simple foot-soldier pawns for White, versus a dark overlord king with spiked crown, sinister robed queen, corrupted plague-priest bishops, skeletal or demonic knights on shadow steeds, dragon-tower rooks with infernal accents, and ragged disposable pawns for Black, all rendered individually in hand-painted medieval illustration style with clear chess silhouettes, high detail, dramatic shading, parchment background, 1:1 aspect ratio, and consistent lighting. IMPORTANT use highly detailed white marble with gold accents for white pieces and black obsidian with dark silver accents for black pieces. They should be highly detailed and look like they were carved from those materials and polished to a high shine. DO NOT MAKE CARTOONS"</div>

                <p class="highlight">4. Animation Style:</p>
                <div class="prompt-block">"Create ultra-violent Excalibur-1980-style medieval fantasy battle animations showing chess pieces as armored warriors made of metal, bone, and enchanted stone brutally hacking, cleaving, crushing, and shattering each other during captures—for example pawns hacking down pawns, knights impaling pawns, rooks smashing queens, bishops cleaving rooks—rendered with hyper-stylized metallic blood-spray, glowing runic energy bursts, slow-motion sword impacts, shattered armor fragments, fog-soaked battle lighting, heavy chromatic bloom, mythic brutality, and the dark, operatic, blood-drenched tone of John Boorman’s Excalibur. IMPORTANT ALWAYS source the characters from the images do not change their appearance or style. These are medieval fantasy chess pieces NOT generic fantasy characters. DO NOT make cartoons or low detail images. Use highly detailed realistic textures and lighting. DO NOT use modern weapons or technology. ONLY the weapons the piece is holding."</div>

                <hr style="border-color: #333; margin: 30px 0;">

                <div style="text-align: center;">
                    <p><strong>Fork the Repo:</strong> <br> <a href="https://github.com/automateyournetwork/BattleChess9000" target="_blank">github.com/automateyournetwork/BattleChess9000</a></p>
                    <p><strong>Contact:</strong> <br> <a href="mailto:ptcapo@gmail.com">ptcapo@gmail.com</a></p>
                    <button onclick="location.reload()" style="margin-top: 20px;">Play Again</button>
                </div>
            </div>
        </div>
    </div>

    <div id="hud" class="ui-layer">
        <h1>Battle Chess AI</h1>
        <div id="player-display"></div>
        <div id="status">Waiting for game start...</div>
    </div>

    <div id="lighting-toggle" class="lighting-toggle" title="Lighting settings">
        ☀
    </div>

    <div id="lighting-panel" class="lighting-panel hidden">
        <h3>Lighting</h3>
        <label>Exposure <span id="val-exposure" class="value">1.0</span></label>
        <input id="slider-exposure" type="range" min="0.3" max="1.5" step="0.05" value="1.0">

        <label>Spotlight <span id="val-spot" class="value">1.10</span></label>
        <input id="slider-spot" type="range" min="0" max="2" step="0.05" value="1.10">

        <label>Ambient <span id="val-ambient" class="value">0.45</span></label>
        <input id="slider-ambient" type="range" min="0" max="1.5" step="0.05" value="0.45">

        <label>Mouse Glow <span id="val-mouse" class="value">0.80</span></label>
        <input id="slider-mouse" type="range" min="0" max="2" step="0.05" value="0.80">

        <label>Bloom <span id="val-bloom" class="value">0.25</span></label>
        <input id="slider-bloom" type="range" min="0" max="1.0" step="0.05" value="0.25">
    </div>

    <div id="check-alert">CHECK!</div>
    <div id="tracker-w" class="tracker tracker-left"></div>
    <div id="tracker-b" class="tracker tracker-right"></div>
    <div id="battle-overlay"><div id="video-msg"></div><video id="battle-video" playsinline></video><button id="skip-btn">Skip</button></div>

    <script>
        // --- CONFIG & GLOBALS ---
        const WS_URL = "wss://battlechess9000-multiplayer-service-960937205198.us-central1.run.app"; 
        
        let CURRENT_THEME = '';
        let PLAYER_COLOR = 'w';
        let PLAYER_NAME = 'Guest';
        const BOARD_SQUARE_SIZE = 10;
        const BOARD_OFFSET = (8 * BOARD_SQUARE_SIZE) / 2 - (BOARD_SQUARE_SIZE / 2);
        let ASSETS_PATH = '';

        const game = new Chess();
        let socket = null;
        let myClientId = null;
        let currentRoomId = null;
        let selectedAvatar = 'w_k'; 
        let isMultiplayer = false;
        let isAIEnabled = false; 
        let isAIThinking = false;
        
        // Showcase State Variables
        let isShowcaseMode = false;
        let scSelectedWhite = null, scSelectedBlack = null, scCurrentMode = 'explore';
        let scCurrentMesh = null; // Track current center mesh for cleanup

        let pendingChallengeId = null;
        let selectedSquare = null;
        let selectedMesh = null;
        let pendingPromotionMove = null;

        const IN_PROGRESS_THEMES = ["super_mario_world"];

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Tone Mapping enabled for bloom/lighting
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;

        document.body.appendChild(renderer.domElement);

        // POST PROCESSING (BLOOM)
        let composer;
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.0, 0.3, 0.85
        );
        bloomPass.threshold = 0.7;   
        bloomPass.strength = 0.25;   
        bloomPass.radius   = 0.35;
        
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // LIGHTING (ENHANCED - Balanced)
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.45);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffaa00, 1.1);
        spotLight.position.set(30, 100, 50);
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        scene.add(spotLight);

        const mouseLight = new THREE.PointLight(0x4da6ff, 0.8, 50);
        mouseLight.position.set(0, 20, 0); 
        scene.add(mouseLight);

        const textureLoader = new THREE.TextureLoader();
        const piecesMap = {};
        const pieceCache = {};
        let particles = [];
        let showcaseHelpers = []; // Store grid/platform to remove them

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const inputState = {
            isPointerDown: false,
            startX: 0,
            startY: 0
        };

        // --- INITIALIZATION ---
        window.onload = function() { 
            loadThemes().then(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const roomId = urlParams.get('room');
                if (roomId) {
                    joinPrivateGame(roomId);
                }
                setupLightingUI();
            });
        };

        function loadThemes() {
            return fetch('assets/themes.json')
                .then(r => {
                    if (!r.ok) throw new Error("Manifest not found");
                    return r.json();
                })
                .then(themes => {
                    const sel = document.getElementById('theme-select');
                    const scSel = document.getElementById('sc-theme-select');
                    sel.innerHTML = '';
                    scSel.innerHTML = '';
                    
                    if (!themes || themes.length === 0) {
                        sel.add(new Option("No themes found", "", true, true));
                        return;
                    }

                    const readyThemes = themes.filter(t => !IN_PROGRESS_THEMES.includes(t));
                    const inProgressThemes = themes.filter(t => IN_PROGRESS_THEMES.includes(t));
                    const pretty = (t) => t.replace(/_/g, ' ').toUpperCase();

                    // Ready Themes
                    if (readyThemes.length > 0) {
                        const grp = document.createElement('optgroup');
                        grp.label = "READY TO PLAY";
                        readyThemes.forEach(t => {
                            const opt = new Option(pretty(t), t);
                            grp.appendChild(opt);
                        });
                        sel.add(grp);
                        scSel.add(grp.cloneNode(true));
                    }

                    // In Progress Themes
                    if (inProgressThemes.length > 0) {
                        const grp = document.createElement('optgroup');
                        grp.label = "UNDER DEVELOPMENT (WIP)";
                        inProgressThemes.forEach(t => {
                             const opt = new Option(`${pretty(t)} [WIP]`, t);
                             grp.appendChild(opt);
                        });
                        sel.add(grp);
                        scSel.add(grp.cloneNode(true));
                    }

                    sel.selectedIndex = 0;
                    scSel.selectedIndex = 0;
                    updateAvatarGrid(); 
                })
                .catch(e => {
                    console.error(e);
                    document.getElementById('theme-select').innerHTML = '<option>Run asset_generator.py first!</option>';
                });
        }

        // --- SHOWCASE LOGIC (NEW) ---
        function openShowcase() {
            document.getElementById('start-menu').classList.remove('active');
            document.getElementById('hud').style.display = 'none';
            document.getElementById('showcase-ui').classList.add('active');
            isShowcaseMode = true;
            
            // Set initial theme from main menu
            const mainSel = document.getElementById('theme-select');
            document.getElementById('sc-theme-select').value = mainSel.value;
            
            updateShowcaseTheme();
        }

        function closeShowcase() {
            document.getElementById('showcase-ui').classList.remove('active');
            document.getElementById('start-menu').classList.add('active');
            document.getElementById('hud').style.display = 'block';
            isShowcaseMode = false;
            
            // Clean up showcase specific items
            clearShowcaseScene();

            // Clear scene
            Object.values(piecesMap).forEach(m => scene.remove(m));
            for(let key in piecesMap) delete piecesMap[key];
            const board = scene.children.find(c => c.geometry && c.geometry.type === 'BoxGeometry');
            if(board) scene.remove(board);
            camera.position.set(0, 60, 80);
        }

        function updateShowcaseTheme() {
            const theme = document.getElementById('sc-theme-select').value;
            CURRENT_THEME = theme;
            ASSETS_PATH = `assets/${CURRENT_THEME}/`;
            
            // FETCH GITHUB CREDIT with 15 commits depth and filter logic
            const creditEl = document.getElementById('sc-credit');
            creditEl.innerHTML = 'Fetching contributor info...';
            
            fetch(`https://api.github.com/repos/automateyournetwork/BattleChess9000/commits?path=assets/${theme}&per_page=15`)
                .then(r => {
                    if(r.status === 403) throw new Error("Rate Limit");
                    return r.json();
                })
                .then(data => {
                    if(data && data.length > 0) {
                        const repoOwner = 'automateyournetwork';
                        // Look for first non-owner or fallback to latest
                        let target = data.find(c => c.author && c.author.login.toLowerCase() !== repoOwner);
                        if (!target) target = data[0];

                        const author = target.author;
                        const commit = target.commit;
                        
                        if(author) {
                            creditEl.innerHTML = `<img src="${author.avatar_url}"> Contributor: <a href="${author.html_url}" target="_blank">@${author.login}</a>`;
                        } else {
                            creditEl.innerText = `Contributor: ${commit.author.name}`;
                        }
                    } else {
                        creditEl.innerText = "Contributor: Unknown (Local or No History)";
                    }
                })
                .catch(e => {
                    console.warn("GitHub API Error:", e);
                    creditEl.innerHTML = `<a href="https://github.com/automateyournetwork/BattleChess9000/graphs/contributors" target="_blank">View All Contributors</a>`;
                });

            // Populate Side Panels
            const pieces = ['k','q','r','b','n','p'];
            const left = document.getElementById('sc-left'); left.innerHTML = '';
            const right = document.getElementById('sc-right'); right.innerHTML = '';
            
            pieces.forEach(p => {
                // White
                const btnW = document.createElement('div'); btnW.className = 'sc-btn';
                btnW.dataset.piece = p; btnW.dataset.color = 'w';
                const imgW = document.createElement('img');
                imgW.src = `${ASSETS_PATH}pieces/${getFullName(p, 'w')}.png`;
                btnW.appendChild(imgW);
                btnW.onclick = () => selectShowcasePiece('w', p, btnW);
                left.appendChild(btnW);

                // Black
                const btnB = document.createElement('div'); btnB.className = 'sc-btn';
                btnB.dataset.piece = p; btnB.dataset.color = 'b';
                const imgB = document.createElement('img');
                imgB.src = `${ASSETS_PATH}pieces/${getFullName(p, 'b')}.png`;
                btnB.appendChild(imgB);
                btnB.onclick = () => selectShowcasePiece('b', p, btnB);
                right.appendChild(btnB);
            });

            // Default View
            showcaseBoard();
        }

        function clearShowcaseScene() {
            // Remove helpers
            showcaseHelpers.forEach(h => scene.remove(h));
            showcaseHelpers = [];
            // Remove any "center" piece
            if(scCurrentMesh) {
                 scene.remove(scCurrentMesh);
                 scCurrentMesh = null;
                 delete piecesMap['center'];
            }
        }

        function showcaseBoard() {
            clearShowcaseScene();
            // Clear regular pieces
            Object.values(piecesMap).forEach(m => scene.remove(m));
            const oldBoard = scene.children.find(c => c.geometry && c.geometry.type === 'BoxGeometry');
            if(oldBoard) scene.remove(oldBoard);
            
            buildSimpleBoard();
            camera.position.set(0, 60, 80);
            camera.lookAt(0,0,0);
            controls.target.set(0, 0, 0); // Reset orbit target
            
            document.querySelectorAll('.sc-btn').forEach(b => b.classList.remove('selected'));
            scSelectedWhite = null; scSelectedBlack = null;
            updateBattleButton();
        }

        function setShowcaseMode(mode) {
            scCurrentMode = mode;
            document.querySelectorAll('.sc-tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`sc-mode-${mode}`).classList.add('active');
            updateBattleButton();
        }

        function selectShowcasePiece(color, type, btnElement) {
            const parent = color === 'w' ? document.getElementById('sc-left') : document.getElementById('sc-right');
            Array.from(parent.children).forEach(c => c.classList.remove('selected'));
            btnElement.classList.add('selected');

            if (color === 'w') scSelectedWhite = type;
            else scSelectedBlack = type;

            if (scCurrentMode === 'explore') {
                clearShowcaseScene();
                
                // Clear Scene of regular board/pieces
                Object.values(piecesMap).forEach(m => scene.remove(m));
                const oldBoard = scene.children.find(c => c.geometry && c.geometry.type === 'BoxGeometry');
                if(oldBoard) scene.remove(oldBoard);

                // Add Platform/Grid for reference
                const platformGeo = new THREE.CylinderGeometry(5, 5.5, 0.5, 32);
                const platformMat = new THREE.MeshStandardMaterial( {color: 0x222222, roughness: 0.2, metalness: 0.8} );
                const platform = new THREE.Mesh( platformGeo, platformMat );
                platform.position.set(0, -0.25, 0);
                platform.receiveShadow = true;
                scene.add( platform );
                showcaseHelpers.push(platform);
                
                const gridHelper = new THREE.GridHelper( 100, 100, 0x444444, 0x111111 );
                scene.add( gridHelper );
                showcaseHelpers.push(gridHelper);

                // Spawn Single Piece in Center
                spawnPiece(type, color, 'center'); 
                const mesh = piecesMap['center'];
                if(mesh) {
                    scCurrentMesh = mesh;
                    mesh.position.set(0, 5.5, 0);
                }
                
                // Focus Camera
                new TWEEN.Tween(camera.position).to({ x: 0, y: 20, z: 40 }, 500).easing(TWEEN.Easing.Quadratic.Out).start();
                controls.target.set(0, 5.5, 0);
            }

            updateBattleButton();
        }

        function updateBattleButton() {
            const btn = document.getElementById('sc-fight-btn');
            if (scCurrentMode === 'battle' && scSelectedWhite && scSelectedBlack) {
                if(scSelectedWhite === 'k' && scSelectedBlack === 'k') btn.style.display = 'none'; 
                else btn.style.display = 'block';
            } else {
                btn.style.display = 'none';
            }
        }

        function triggerShowcaseBattle() {
            const wName = getFullName(scSelectedWhite, 'w').split('_')[1];
            const bName = getFullName(scSelectedBlack, 'b').split('_')[1];
            const filename = `white_${wName}_takes_black_${bName}.mp4`;
            playVideoFile(filename, () => { /* Animation done */ });
        }


        // --- AVATAR & SETUP ---
        function updateAvatarGrid() {
            const theme = document.getElementById('theme-select').value;
            const safeTheme = theme || 'medieval_classic'; 
            const grid = document.getElementById('avatar-grid');
            grid.innerHTML = '';
            
            const pieces = ['w_k', 'w_q', 'w_r', 'w_b', 'w_n', 'w_p', 'b_k', 'b_q', 'b_r', 'b_b', 'b_n', 'b_p'];
            const map = {
                'w_k': 'white_king', 'w_q': 'white_queen', 'w_r': 'white_rook', 'w_b': 'white_bishop', 'w_n': 'white_knight', 'w_p': 'white_pawn',
                'b_k': 'black_king', 'b_q': 'black_queen', 'b_r': 'black_rook', 'b_b': 'black_bishop', 'b_n': 'black_knight', 'b_p': 'black_pawn'
            };

            pieces.forEach(code => {
                const div = document.createElement('div');
                div.className = `avatar-option ${code === selectedAvatar ? 'selected' : ''}`;
                div.onclick = () => {
                    selectedAvatar = code;
                    document.querySelectorAll('.avatar-option').forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                };
                const img = document.createElement('img');
                img.src = `assets/${safeTheme}/pieces/${map[code]}.png`;
                img.onerror = function() { this.style.opacity = 0.3; }; 
                div.appendChild(img);
                grid.appendChild(div);
            });
        }

        function setupGameCommon() {
            const nameInput = document.getElementById('player-name-input');
            const sel = document.getElementById('theme-select');
            if(!sel.value) { alert("Please select a theme first"); return false; }
            
            PLAYER_NAME = nameInput.value.trim() || "Commander";
            CURRENT_THEME = sel.value;
            ASSETS_PATH = `assets/${CURRENT_THEME}/`;
            document.getElementById('start-menu').classList.remove('active');
            
            // Set Camera Default
            camera.position.set(0, 60, 80);
            camera.lookAt(0,0,0);
            return true;
        }

        function startGameAI() {
            if(!setupGameCommon()) return;
            initVisuals();
            isMultiplayer = false;
            isAIEnabled = true;
            PLAYER_COLOR = 'w';
            document.getElementById('player-display').innerText = `${PLAYER_NAME} VS AI (CPU)`;
            updateStatus();
        }

        function startGameLocal() {
            if(!setupGameCommon()) return;
            initVisuals();
            isMultiplayer = false;
            isAIEnabled = false;
            PLAYER_COLOR = 'w';
            document.getElementById('player-display').innerText = `LOCAL PVP (HOTSEAT)`;
            updateStatus();
        }
        
        function initVisuals() {
            game.reset();
            // Clear pieces but keep lights
            Object.values(piecesMap).forEach(mesh => scene.remove(mesh));
            // Rebuild board and pieces
            buildSimpleBoard();
            initPieces();
        }

        // --- MULTIPLAYER ---
        function connectSocket() {
            socket = new WebSocket(WS_URL);
            socket.onmessage = (e) => handleNetworkMessage(JSON.parse(e.data));
            socket.onclose = () => { 
                alert("Disconnected."); 
                if (!window.isReloading) window.location.href = window.location.pathname; 
            };
            return socket;
        }

        function joinLobby() {
            if(!setupGameCommon()) return;
            document.getElementById('lobby-menu').classList.add('active');
            updateMyAvatarDisplay();
            isMultiplayer = true;
            isAIEnabled = false;
            const ws = connectSocket();
            ws.onopen = () => ws.send(JSON.stringify({ type: 'login', name: PLAYER_NAME, avatar: selectedAvatar }));
        }

        function createPrivateGame() {
            if(!setupGameCommon()) return;
            document.getElementById('invite-menu').classList.add('active');
            isMultiplayer = true;
            isAIEnabled = false;
            const ws = connectSocket();
            ws.onopen = () => ws.send(JSON.stringify({ type: 'create_private', name: PLAYER_NAME, avatar: selectedAvatar }));
        }

        function joinPrivateGame(roomId) {
            const sel = document.getElementById('theme-select');
            if(!sel.value && sel.options.length > 0) sel.selectedIndex = 0;
            setupGameCommon();
            isMultiplayer = true;
            isAIEnabled = false;
            const ws = connectSocket();
            ws.onopen = () => ws.send(JSON.stringify({ type: 'join_private', roomId: roomId, name: PLAYER_NAME, avatar: selectedAvatar }));
        }

        function disconnectSocket() {
            if(socket) { window.isReloading = true; socket.close(); }
            window.location.href = window.location.pathname;
        }
        
        function updateMyAvatarDisplay() {
            const fullMap = { 'w_k': 'white_king', 'w_q': 'white_queen', 'b_k': 'black_king', 'b_q': 'black_queen' }; // simplified map for lobby
            const pieceName = fullMap[selectedAvatar] || 'white_king';
            document.getElementById('my-avatar-display').src = `${ASSETS_PATH}pieces/${pieceName}.png`;
            document.getElementById('my-name-display').innerText = PLAYER_NAME;
        }

        function handleNetworkMessage(msg) {
            if (msg.type === 'login_success') myClientId = msg.myId;
            if (msg.type === 'lobby_update') renderLobbyList(msg.players);
            if (msg.type === 'private_created') {
                const link = `${window.location.protocol}//${window.location.host}${window.location.pathname}?room=${msg.roomId}`;
                document.getElementById('invite-link-box').value = link;
            }
            if (msg.type === 'challenge_received') {
                pendingChallengeId = msg.fromId;
                document.getElementById('challenger-name').innerText = `${msg.fromName} wants to battle!`;
                document.getElementById('challenge-modal').classList.add('active');
            }
            if (msg.type === 'error') { alert(msg.message); disconnectSocket(); }
            if (msg.type === 'game_start') {
                document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
                currentRoomId = msg.roomId;
                PLAYER_COLOR = msg.color;
                document.getElementById('player-display').innerText = `VS ${msg.opponent}`;
                initVisuals();
                const isMobile = window.innerWidth < 768;
                const z = (PLAYER_COLOR === 'w') ? (isMobile ? 110 : 80) : (isMobile ? -110 : -80);
                camera.position.set(0, isMobile ? 80 : 60, z);
                camera.lookAt(0,0,0);
                updateStatus();
            }
            if (msg.type === 'move') executeMove(msg.move, true);
            if (msg.type === 'opponent_disconnected') {
                alert("Opponent disconnected!");
                triggerGameOver("Opponent Disconnected");
            }
        }

        function renderLobbyList(players) {
            const list = document.getElementById('lobby-list');
            list.innerHTML = '';
            const opponents = players.filter(p => p.id !== myClientId);
            if (opponents.length === 0) { list.innerHTML = '<li style="padding:20px; text-align:center; color:#666;">Waiting for players...</li>'; return; }
            opponents.forEach(p => {
                const li = document.createElement('li');
                li.className = 'player-item';
                const avatarUrl = `assets/${CURRENT_THEME}/pieces/white_king.png`; // Fallback visual
                li.innerHTML = `
                    <div class="player-info"><img src="${avatarUrl}" style="width:30px;"><div><div style="font-weight:bold; color:#fff;">${p.name}</div><span class="player-stats">W:${p.stats.wins} L:${p.stats.losses}</span></div></div>
                    <button class="challenge-btn" onclick="sendChallenge('${p.id}')">FIGHT</button>`;
                list.appendChild(li);
            });
        }

        function sendChallenge(targetId) { socket.send(JSON.stringify({ type: 'challenge_request', targetId })); alert("Challenge sent!"); }
        function acceptChallenge() { socket.send(JSON.stringify({ type: 'challenge_accept', targetId: pendingChallengeId })); }
        function declineChallenge() { document.getElementById('challenge-modal').classList.remove('active'); pendingChallengeId = null; }

        // --- LIGHTING UI HOOKUP ---
        function setupLightingUI() {
            const toggleEl = document.getElementById('lighting-toggle');
            const panelEl  = document.getElementById('lighting-panel');
        
            toggleEl.addEventListener('click', () => {
                panelEl.classList.toggle('hidden');
            });
        
            // Helper to wire a slider
            function bindSlider(sliderId, labelId, getVal, setVal, decimals = 2) {
                const slider = document.getElementById(sliderId);
                const label  = document.getElementById(labelId);
                if (!slider || !label) return;
            
                // initial
                slider.value = getVal().toFixed(decimals);
                label.textContent = getVal().toFixed(decimals);
            
                slider.addEventListener('input', () => {
                    const v = parseFloat(slider.value);
                    setVal(v);
                    label.textContent = v.toFixed(decimals);
                });
            }
        
            bindSlider('slider-exposure', 'val-exposure', () => renderer.toneMappingExposure, v => renderer.toneMappingExposure = v);
            bindSlider('slider-spot', 'val-spot', () => spotLight.intensity, v => spotLight.intensity = v);
            bindSlider('slider-ambient', 'val-ambient', () => ambientLight.intensity, v => ambientLight.intensity = v);
            bindSlider('slider-mouse', 'val-mouse', () => mouseLight.intensity, v => mouseLight.intensity = v);
            bindSlider('slider-bloom', 'val-bloom', () => bloomPass.strength, v => bloomPass.strength = v);
        }

        // --- GAMEPLAY VISUALS ---
        function buildSimpleBoard() {
            const boardTexture = textureLoader.load(ASSETS_PATH + 'board_texture.png', (tex) => { tex.encoding = THREE.sRGBEncoding; });
            const boardGeo = new THREE.BoxGeometry(84, 1, 84);
            const boardMat = new THREE.MeshStandardMaterial({ 
                map: boardTexture, 
                color: 0xdddddd, // offwhite
                roughness: 0.35, // adds some matte so it doesn’t blow out
                metalness: 0.1
            });
            const board = new THREE.Mesh(boardGeo, boardMat);
            board.position.y = -0.5;
            board.receiveShadow = true;
            scene.add(board);
        }

        function spawnPiece(type, color, square) {
            const fname = getFullName(type, color);
            const path = `${ASSETS_PATH}pieces/${fname}.png`;
            
            // RESTORED: Chroma Key Texture Loading (Removes Black/White Squares)
            const texture = loadChromaTexture(fname, path, color);
            const material = new THREE.MeshStandardMaterial({ 
                map: texture, 
                transparent: true, 
                side: THREE.DoubleSide,
                alphaTest: 0.5,
                roughness: 0.55,   // a bit more matte
                metalness: 0.1
            });
            
            const geometry = new THREE.PlaneGeometry(11.5, 11.5);
            const mesh = new THREE.Mesh(geometry, material);
            
            if (square === 'center') {
                mesh.position.set(0, 5.5, 0); // Center for Showcase
            } else {
                const pos = squareToVector(square);
                mesh.position.set(pos.x, pos.y, pos.z);
            }
            
            // Always face camera but keep upright (CYLINDRICAL BILLBOARDING)
            mesh.rotation.x = 0; // Vertical
            
            mesh.customDepthMaterial = new THREE.MeshDepthMaterial({
                depthPacking: THREE.RGBADepthPacking,
                map: texture,
                alphaTest: 0.5
            });
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            mesh.userData = { type: type, color: color, square: square };
            scene.add(mesh);
            piecesMap[square] = mesh;
        }

        function spawnParticles(pos, color) {
            const geometry = new THREE.BufferGeometry();
            const count = 50;
            const positions = new Float32Array(count * 3);
            const velocities = [];
            
            for(let i=0; i<count; i++) {
                positions[i*3] = pos.x;
                positions[i*3+1] = pos.y;
                positions[i*3+2] = pos.z;
                velocities.push({
                    x: (Math.random()-0.5) * 1.5,
                    y: (Math.random()) * 1.5,
                    z: (Math.random()-0.5) * 1.5
                });
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ size: 0.8, color: color === 'w' ? 0xffffff : 0xff0000, transparent: true, opacity: 1 });
            const pts = new THREE.Points(geometry, material);
            scene.add(pts);
            
            particles.push({ mesh: pts, vels: velocities, life: 1.0 });
        }

        function initPieces() {
            const boardState = game.board();
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = boardState[r][c];
                    if (p) spawnPiece(p.type, p.color, String.fromCharCode(97 + c) + (8 - r));
                }
            }
        }

        // --- CORE GAMEPLAY ---
        function onInteraction(clientX, clientY) {
            if(document.getElementById('battle-overlay').style.display === 'flex') return;
            if(isShowcaseMode) return; // No game logic in showcase

            if((isAIEnabled || isMultiplayer) && game.turn() !== PLAYER_COLOR) return;
            
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children);
            // Mouse Light logic
            if(intersects.length > 0) {
                const pt = intersects[0].point;
                mouseLight.position.set(pt.x, 8, pt.z); // Update light Y if needed
            }

            const pieceIntersects = raycaster.intersectObjects(Object.values(piecesMap));
            if (pieceIntersects.length > 0) {
                const mesh = pieceIntersects[0].object;
                const square = mesh.userData.square;
                if (game.get(square).color === game.turn()) { selectPiece(square); return; }
                else if (selectedSquare) { attemptMove(square); return; }
            }

            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            if (target && selectedSquare) {
                const fileIdx = Math.floor((target.x + BOARD_OFFSET + BOARD_SQUARE_SIZE/2) / BOARD_SQUARE_SIZE);
                const rankIdx = Math.floor((target.z + BOARD_OFFSET + BOARD_SQUARE_SIZE/2) / BOARD_SQUARE_SIZE);
                if (fileIdx >= 0 && fileIdx < 8 && rankIdx >= 0 && rankIdx < 8) {
                    attemptMove(String.fromCharCode(97 + fileIdx) + (8 - rankIdx));
                }
            }
        }

        // Interaction Listeners
        renderer.domElement.addEventListener('pointerdown', (e) => { if(e.button===0){ inputState.isPointerDown=true; inputState.startX=e.clientX; inputState.startY=e.clientY; } });
        renderer.domElement.addEventListener('pointerup', (e) => { 
            if(!inputState.isPointerDown) return; 
            inputState.isPointerDown=false; 
            if(Math.sqrt(Math.pow(e.clientX-inputState.startX,2)+Math.pow(e.clientY-inputState.startY,2))<10) onInteraction(e.clientX, e.clientY);
        });
        renderer.domElement.addEventListener('mousemove', (e) => {
            // Update light pos passively
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            if(intersects.length > 0) {
                const pt = intersects[0].point;
                // Move light smoothly
                new TWEEN.Tween(mouseLight.position).to({ x: pt.x, z: pt.z }, 50).start();
            }
        });

        // --- MOVEMENT LOGIC (Condensed for stability) ---
        function selectPiece(square) {
            if (selectedMesh) selectedMesh.material.emissive.setHex(0x000000);
            selectedSquare = square;
            selectedMesh = piecesMap[square];
            if (selectedMesh) selectedMesh.material.emissive.setHex(0x333333); // Subtle glow
        }

        function attemptMove(targetSquare) {
            const piece = game.get(selectedSquare);
            if (piece.type === 'p' && (targetSquare[1] === '8' || targetSquare[1] === '1')) {
                const tempMove = new Chess(game.fen());
                if(tempMove.move({from:selectedSquare, to:targetSquare, promotion:'q'})) {
                    pendingPromotionMove = { from: selectedSquare, to: targetSquare };
                    document.getElementById('promo-modal').classList.add('active');
                    return;
                }
            }
            executeMove({ from: selectedSquare, to: targetSquare, promotion: 'q' });
        }

        function commitPromotion(p) {
            document.getElementById('promo-modal').classList.remove('active');
            if(pendingPromotionMove) { executeMove({ ...pendingPromotionMove, promotion: p }); pendingPromotionMove=null; }
        }

        function executeMove(moveObj, isNetworkMove = false) {
            let move = isNetworkMove ? game.move(moveObj) : game.move(moveObj);
            if (move) {
                if(selectedMesh) selectedMesh.material.emissive.setHex(0x000000);
                selectedSquare = null; selectedMesh = null;
                if (isMultiplayer && !isNetworkMove && socket) socket.send(JSON.stringify({ type: 'move', roomId: currentRoomId, move: moveObj }));
                
                handleMoveVisuals(move, () => {
                    updateStatus();
                    if (game.game_over()) {
                        if (game.in_checkmate()) {
                            playCheckmateAnimation(move);
                            if(isMultiplayer && !isNetworkMove && socket) socket.send(JSON.stringify({ type: 'game_over', winnerName: game.turn()==='w'?'Black':'White', loserName: game.turn()==='w'?'White':'Black' }));
                        } else triggerGameOver(game.in_draw()?"Draw":"Game Over");
                    } else if (isAIEnabled && game.turn() !== PLAYER_COLOR) {
                        isAIThinking = true; document.getElementById('status').innerText = "AI thinking...";
                        setTimeout(makeAIMove, 800);
                    }
                });
            }
        }

        function makeAIMove() {
            const moves = game.moves({ verbose: true });
            if (moves.length === 0) return;
            let bestMove = moves.find(m => m.captured) || moves[Math.floor(Math.random() * moves.length)];
            if(bestMove.promotion) bestMove.promotion = 'q';
            game.move(bestMove);
            handleMoveVisuals(bestMove, () => { isAIThinking=false; updateStatus(); if(game.game_over()) triggerGameOver(); });
        }

        function handleMoveVisuals(move, onComplete) {
            const originSquare = move.from;
            const destSquare = move.to;
            const pieceMesh = piecesMap[originSquare];
            const targetPos = squareToVector(destSquare);

            if (move.captured) {
                updateCaptures(move.captured, move.color);
                // Particle Explosion!
                const victim = piecesMap[destSquare];
                if(victim) spawnParticles(victim.position, move.color === 'w' ? 'b' : 'w'); // Opponent color explodes
            }

            if (move.flags.includes('k') || move.flags.includes('q')) { // Castling
                let rookSrc = move.color==='w'?(move.flags.includes('k')?'h1':'a1'):(move.flags.includes('k')?'h8':'a8');
                let rookDst = move.color==='w'?(move.flags.includes('k')?'f1':'d1'):(move.flags.includes('k')?'f8':'d8');
                finishMove(piecesMap[rookSrc], squareToVector(rookDst), rookSrc, rookDst, null);
            }

            // Normal or Capture Move
            if(move.captured) {
                playKillVideo(move, () => {
                    const victimMesh = piecesMap[destSquare];
                    if(victimMesh) scene.remove(victimMesh);
                    if(move.promotion) {
                        scene.remove(pieceMesh); spawnPiece(move.promotion, move.color, originSquare);
                        finishMove(piecesMap[originSquare], targetPos, originSquare, destSquare, onComplete);
                    } else finishMove(pieceMesh, targetPos, originSquare, destSquare, onComplete);
                });
            } else {
                if(move.promotion) { scene.remove(pieceMesh); spawnPiece(move.promotion, move.color, originSquare); finishMove(piecesMap[originSquare], targetPos, originSquare, destSquare, onComplete); }
                else finishMove(pieceMesh, targetPos, originSquare, destSquare, onComplete);
            }
        }

        function finishMove(mesh, targetPos, oldSquare, newSquare, onComplete) {
            // Jump animation
            new TWEEN.Tween(mesh.position).to({ x: targetPos.x, z: targetPos.z }, 400).easing(TWEEN.Easing.Quadratic.Out).onComplete(() => { if(onComplete) onComplete(); }).start();
            // Small hop
            new TWEEN.Tween(mesh.position).to({ y: 5 }, 200).yoyo(true).repeat(1).start();
            
            delete piecesMap[oldSquare];
            piecesMap[newSquare] = mesh;
            mesh.userData.square = newSquare;
        }

        // --- UTILS ---
        function squareToVector(sq) { return new THREE.Vector3((sq.charCodeAt(0)-97)*10 - 35, 5.5, (8-parseInt(sq[1]))*10 - 35); }
        function getFullName(type, color) { return `${color==='w'?'white':'black'}_${{'p':'pawn','n':'knight','b':'bishop','r':'rook','q':'queen','k':'king'}[type]}`; }
        
        // RESTORED: Chroma Key Texture Loading (Removes Black/White Squares)
        function loadChromaTexture(name, path, color) {
            if(pieceCache[name]) return pieceCache[name];
            const tex = new THREE.Texture(); 
            const img = new Image(); 
            img.src = path;
            img.onload = () => {
                const canvas = document.createElement('canvas'); 
                canvas.width = img.width; 
                canvas.height = img.height;
                const ctx = canvas.getContext('2d'); 
                ctx.drawImage(img, 0, 0);
                
                const idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const d = idata.data;
                // Manual Chroma Key to make background transparent
                for(let i=0; i<d.length; i+=4) {
                    const r=d[i], g=d[i+1], b=d[i+2];
                    if (color === 'w') { 
                        if(r < 40 && g < 40 && b < 40) d[i+3] = 0; // Remove Black
                    } else { 
                        if(r > 215 && g > 215 && b > 215) d[i+3] = 0; // Remove White
                    }
                }
                ctx.putImageData(idata, 0, 0);
                
                tex.image = canvas; 
                tex.needsUpdate = true; 
                tex.encoding = THREE.sRGBEncoding;
            };
            pieceCache[name] = tex; 
            return tex;
        }

        function getTransparentIconUrl(path, color, cb) { const img=new Image(); img.crossOrigin="Anonymous"; img.src=path; img.onload=()=>{ const c=document.createElement('canvas'); c.width=img.width; c.height=img.height; c.getContext('2d').drawImage(img,0,0); cb(c.toDataURL()); }; }
        function updateCaptures(p, c) { const n = getFullName(p, c==='w'?'b':'w'); getTransparentIconUrl(`${ASSETS_PATH}pieces/${n}.png`, c, (u)=>{ const i=document.createElement('img'); i.src=u; i.className='capture-icon'; document.getElementById(c==='w'?'tracker-w':'tracker-b').appendChild(i); }); }
        
        function updateStatus() {
            let st = ''; let c = game.turn()==='w'?'White':'Black';
            Object.values(piecesMap).forEach(p => p.material.emissive.setHex(0x000000));
            document.getElementById('check-alert').style.display='none';
            if(game.in_check()) {
                document.getElementById('check-alert').style.display='block'; setTimeout(()=>document.getElementById('check-alert').style.display='none',2500);
                // Highlight King
                const k = Object.values(piecesMap).find(m => m.userData.type === 'k' && m.userData.color === game.turn());
                if(k) k.material.emissive.setHex(0xff0000);
            }
            if(game.in_checkmate()) st=`CHECKMATE! ${c==='White'?'Black':'White'} WINS!`;
            else if(game.in_draw()) st='DRAW';
            else st = `${c} to move`;
            document.getElementById('status').innerText = st;
        }

        function triggerGameOver(r) { document.getElementById('end-title').innerText = r || "GAME OVER"; setTimeout(()=>document.getElementById('game-over-modal').classList.add('active'), 1000); }

        // --- VIDEO ---
        const vid = document.getElementById('battle-video');
        const overlay = document.getElementById('battle-overlay');
        let onVideoEnd = null;
        document.getElementById('skip-btn').onclick = stopVideo;
        function playKillVideo(move, cb) { playVideoFile(`${move.color==='w'?'white':'black'}_${getFullName(move.piece,move.color).split('_')[1]}_takes_${move.color==='w'?'black':'white'}_${getFullName(move.captured,move.color==='w'?'b':'w').split('_')[1]}.mp4`, cb); }
        function playCheckmateAnimation(move) { playVideoFile(`${move.color==='w'?'white':'black'}_${getFullName(move.piece,move.color).split('_')[1]}_takes_${move.color==='w'?'black':'white'}_king.mp4`, ()=>triggerGameOver()); }
        function playVideoFile(f, cb) { 
            onVideoEnd=cb; const p=`${ASSETS_PATH}videos/${f}`; document.getElementById('video-msg').innerText=`Loading: ${f}`; vid.src=p; overlay.style.display='flex';
            vid.play().then(()=>{ document.getElementById('video-msg').innerText=""; }).catch(()=>{ setTimeout(stopVideo,1000); }); vid.onended=stopVideo;
        }
        function stopVideo() { vid.pause(); overlay.style.display='none'; if(onVideoEnd){ onVideoEnd(); onVideoEnd=null; } }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            
            // Billboard pieces - CYLINDRICAL (Y-axis only)
            for(let key in piecesMap) {
                const mesh = piecesMap[key];
                // mesh.lookAt(camera.position); 
                mesh.lookAt(camera.position.x, mesh.position.y, camera.position.z);
            }

            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.life -= 0.02;
                const positions = p.mesh.geometry.attributes.position.array;
                for(let j=0; j<50; j++) {
                    positions[j*3] += p.vels[j].x;
                    positions[j*3+1] += p.vels[j].y;
                    positions[j*3+2] += p.vels[j].z;
                    p.vels[j].y -= 0.05; // Gravity
                }
                p.mesh.geometry.attributes.position.needsUpdate = true;
                p.mesh.material.opacity = p.life;
                if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }

            composer.render();
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); });
    </script>
</body>
</html>